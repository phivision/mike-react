type UserProfile @model(subscriptions: null) @searchable
@auth(rules: [{ allow: owner, ownerField: "owner", operations: [create, delete, update] },
  { allow: private, operations: [read]},
  { allow: public, provider: iam, operations: [read]}])
@key(name: "profilesByStripeID", fields: ["StripeID"], queryField: "profilesByStripeID")
@key(name: "profilesByURL", fields: ["LandingURL"], queryField: "profilesByURL")
{
  id: ID!
  Birthday: AWSDate
  Email: AWSEmail
  Gender: String
  Height: Float
  RegDate: String!
  StripeID: String
  UserImage: String
  BgImage: String
  BgTitle: String
  LastName: String
  FirstName: String
  UserRole: String!
  Weight: Float
  IsVerified: Boolean
  Description: String
  Biography: String
  LandingURL: String
  TokenBalance: Int
  TokenPrice: Int
  owner: String!
  """
  Apple device token for push notifications
  """
  DeviceToken: String
  """
  A list of user's favorite contents
  """
  Favorites: [UserFavoriteContent] @connection(name: "byFavoriteContent")
  """
  A list of contents generated by the user aka the creator or trainer
  """
  Contents: [UserContent] @connection(keyName: "byContent", fields: ["id"])
  """
  A list of subscriptions which is being paid or has been paid by the user
  """
  Subscriptions: [UserSubscriptionTrainer] @connection(name: "byUserSubscription")
  """
  A list of users who is subscripting to one or a few trainers
  """
  Users: [UserSubscriptionTrainer] @connection(name: "bySubscriptedTrainer")
}

# create a join model and disable query for m2m relationship
type UserSubscriptionTrainer @model(subscriptions: null)
@auth(rules: [{ allow: owner, operations: [create, delete, update] },
  { allow: private, operations: [read]},
  { allow: public, provider: iam, operations: [read]}]){
  id: ID!
  StripeID: String!
  ExpireDate: AWSDate!
  CancelAtPeriodEnd: Boolean!
  Trainer: UserProfile! @connection(name: "bySubscriptedTrainer")
  User: UserProfile! @connection(name: "byUserSubscription")
}

type UserFavoriteContent @model(queries: null, subscriptions: null)
@auth(rules: [{ allow: owner, operations: [create, delete, update] },
  { allow: private, operations: [read]},
  { allow: public, provider: iam, operations: [read]}]){
  id: ID!
  User: UserProfile! @connection(name: "byFavoriteContent")
  Content: UserContent! @connection(name: "byFavoriteUser")
}

type UserContent @model(subscriptions: null)
@auth(rules: [{ allow: owner, operations: [create, delete, update] },
  { allow: private, operations: [read]},
  { allow: public, provider: iam, operations: [read]}])
@key(name: "byContent", fields: ["CreatorID", "createdAt"], queryField: "byContentCreatedAt")
@key(name: "byName", fields: ["ContentName"], queryField: "contentByName")
{
  id: ID!
  """
  The ID of the user who created and own this content
  """
  CreatorID: ID!
  createdAt: AWSDateTime!
  ContentName: String!
  Description: String
  Title: String
  """
  The level indicates the difficulty of the training course, e.g. 1 => easy, 2=> medium, 3=>hard
  """
  Level: Int
  Length: Float
  IsDemo: Boolean
  TranscodeReady: Boolean
  ViewCount: Int
  Thumbnail: String
  Preview: String
  Segments: AWSJSON
  Creator: UserProfile @connection(fields: ["CreatorID"])
  """
  A list of users who like this content
  """
  FavoriteUser: [UserFavoriteContent] @connection(name: "byFavoriteUser")
}

type Message @model(subscriptions: null)
@auth(rules: [{ allow: owner, operations: [create, delete] },
              { allow: public, provider: iam, operations: [read] }])
@key(name: "byToUser", fields: ["ToUserID", "createdAt"], queryField: "messageByToUserID")
@key(name: "byFromUser", fields: ["FromUserID", "createdAt"], queryField: "messageByFromUserID")
  {
  id: ID!
  PostMessages: String!
  FromUserID: ID!
  ToUserID: ID!
  createdAt: AWSDateTime!
  """
  The message type can be text, voice, image, video, etc
  """
  Type: MessageType
  """
  The message status, unread, read bu unresponded, responded, etc
  """
  Status: MessageStatus
  FromUser: UserProfile! @connection(fields: ["FromUserID"])
  ToUser: UserProfile! @connection(fields: ["ToUserID"])
}

type TrainerConnection @aws_iam @aws_cognito_user_pools {
  items: [UserProfile]
  nextToken: String
}

enum MessageStatus {
  UNREAD
  UNRESPONDED
  RESPONDED
}

enum MessageType {
  TEXT
  VOICE
  IMAGE
  VIDEO
}

type Subscription {
  onContentByCreatorID(CreatorID: ID!): UserContent @aws_subscribe(mutations: ["createUserContent"])
  onUpdateByCreatorID(CreatorID: ID!): UserContent @aws_subscribe(mutations: ["updateUserContent"])
  onDeletionByCreatorID(CreatorID: ID!): UserContent @aws_subscribe(mutations: ["deleteUserContent"])
  onMessagesByToUserID(ToUserID: ID!): Message @aws_subscribe(mutations: ["createMessage"])
}

type Query {
  trainerSearch(keyword: String!): TrainerConnection @aws_iam @aws_cognito_user_pools
}